<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="MobileOptimized" content="width"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MPN.tray</title>
  <style>

/* //desktop */
@media only screen
and (min-width : 1200) {


}

/* //tablet landscape */
@media screen and (min-width: 1024px) and (max-width: 1600px)  {

} 
/* // end media query */

/* //tablet portrait */
@media screen and (min-width: 768px) and (max-width: 1023px)  {

}
/* //end media definition */


/* //smartphone landscape */
@media screen and (min-width: 480px) and (max-width: 767px)  {

}
/* //end media query */



/* //smartphone portrait */
@media screen /*and (min-width: 320px)*/
and (max-width: 479px) {
}

/* //end media query */

    /* USWDS-inspired styles */
body {
  background-color: #f0f0f0;
  font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;
  color: #1b1b1b;
  margin: 0;
  padding: 0;
}

h2 {
  font-family: 'Merriweather', 'Georgia', serif;
  color: #205493;
  font-size: 2rem;
  margin-bottom: 1rem;
}

.controls, .input-group {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

.controls label, .input-group label {
  width: 160px;
  min-width: 120px;
  font-weight: 600;
  color: #323a45;
  margin-right: 1rem;
  text-align: right;
}

.controls input[type="number"], .input-group input[type="number"] {
  width: 70px;
  padding: 0.5rem;
  border: 2px solid #aeb0b5;
  border-radius: 4px;
  font-size: 1rem;
  font-family: inherit;
  background: #fff;
  color: #1b1b1b;
  margin-right: 1rem;
}

button, #generateButton, #button {
  background-color: #0071bc;
  color: #fff;
  border: none;
  border-radius: 4px;
  padding: 0.5rem 1.2rem;
  font-size: 1rem;
  font-family: inherit;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s;
  margin-left: 0.5rem;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

button:hover, #generateButton:hover, #button:hover {
  background-color: #205493;
}

#results {
  background: #fff;
  border: 1px solid #d6d7d9;
  border-radius: 4px;
  padding: 1rem;
  margin-top: 1rem;
  min-height: 2rem;
  color: #205493;
  font-size: 1.1rem;
}

input:focus, button:focus {
  outline: 3px solid #2491ff;
  outline-offset: 2px;
}

.controls, .input-group {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}
@media (max-width: 600px) {
  .controls {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
  .controls label {
    width: auto !important;
    min-width: unset !important;
    margin-right: 0 !important;
    margin-bottom: 0.25rem;
    text-align: left !important;
  }
}
.tray-controls {
  align-items: flex-start;
  gap: 0.5rem;
}

.tray-label {
  width: auto;
  min-width: unset;
  font-weight: 600;
  color: #323a45;
  margin-right: 1rem;
  text-align: right;
  padding-top: 0.1rem;
}

.tray-radio-group {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.tray-radio-group label {
  margin: 0;
  font-weight: 400;
  color: #323a45;
  display: flex;
  align-items: center;
  font-size: 1rem;
}

@media (max-width: 600px) {
  .tray-controls {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.25rem;
  }
  .tray-label {
    text-align: left !important;
    margin-right: 0 !important;
    margin-bottom: 0.25rem;
    width: auto !important;
    min-width: unset !important;
  }
  .tray-radio-group {
    gap: 0.15rem;
  }
}

/* Add to your existing CSS */
.batch-controls {
  display: flex;
  flex-direction: column;
  gap: 0.8rem;
  align-items: flex-start;
  margin: 1rem 0;
  /* Remove or comment out the next line */
  /* padding-left: 160px; */
}

/* Remove the column direction from batch-input */
.batch-input {
  display: flex;
  align-items: center;
  width: auto;
}

/* Update the file input wrapper styles */
.file-input-wrapper {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 0.5rem;
}

.file-input-wrapper input[type="file"] {
  display: none;
}

.file-input-wrapper label {
  background-color: #0071bc;
  color: #fff;
  border: none;
  border-radius: 4px;
  padding: 0.5rem 1.2rem;
  font-size: 1rem;
  font-family: inherit;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s;
  min-width: 120px;
  text-align: center;
}

.file-input-wrapper label:hover {
  background-color: #205493;
}

.file-name {
  color: #323a45;
  font-size: 1rem;
  margin-left: 1rem;
}
    </style>
  
</head>
<body>
  <div class="parent-container">
    <div class="grid-container" id="grid-container-1"></div>
    <div class="text-container">
      <h2>MPN.tray</h2>
    </div>
    <div class="grid-container" id="grid-container-2"></div>
  </div>
  <br><br>
  <div class="controls tray-controls">
  <label class="tray-label">
    Select System:
  </label>
  <div class="tray-radio-group">
    <label>
      <input type="radio" name="numLevels" id="numLevels1" value="1" onchange="handleNumLevelsChange()" />
      1
    </label>
    <label>
      <input type="radio" name="numLevels" id="numLevels2" value="2" onchange="handleNumLevelsChange()" checked />
      2
    </label>
  </div>
</div>
  <div id="inputFields"></div>
  <br>
  <div id="results" style="margin-top: 20px;"></div>
 
  
  <script>
    //unique id for mpn session
	function generateSecureSessionID() {
  return 'SID' + crypto.getRandomValues(new Uint32Array(1))[0].toString(36);
}
const sessionID = generateSecureSessionID();
console.log(sessionID);
  
    // Create grid logo
    const gridContainer1 = document.getElementById('grid-container-1');
    createGrid(gridContainer1);

    function createGrid(container) {
      for (let i = 0; i < 48; i++) {
        const gridItem = document.createElement('div');
        gridItem.classList.add('grid-item');

        // Randomly decide whether to make the grid item black
        if (Math.random() < 0.6) {
          gridItem.classList.add('black');
        }

        container.appendChild(gridItem);
      }
    }
  // end grid func

    // Replace all uses of document.getElementById('numLevels').value with getSelectedNumLevels()
  function getSelectedNumLevels() {
    const selected = document.querySelector('input[name="numLevels"]:checked');
    return selected ? Number(selected.value) : 2;
  }

  function handleNumLevelsChange() {
    addDilutionLevels(getSelectedNumLevels());
  }

  // Update addDilutionLevels to accept numLevels as a parameter
  function addDilutionLevels(numLevels) {
    if (![1, 2].includes(numLevels)) {
      alert('Please select 1 or 2.');
      return;
    }
    const container = document.getElementById('inputFields');
    container.innerHTML = ''; // Clear previous inputs

    // Clear the results display
    document.getElementById('results').innerHTML = '';

    // Predefined values that won't be shown to users
    const defaultValues = {
      1: {
        d: [0.01],
        w: [1.96],
        n: [51]
      },
      2: {
        d: [0.01, 0.01],
        w: [1.90, 0.16],
        n: [49, 48]
      }
    };

    for (let i = 0; i < numLevels; i++) {
      let defaultPositive = numLevels === 1 ? 30 : (i === 0 ? 30 : 3);

      container.innerHTML += `
        <div class="input-group">
          <label for="x${i}">Positive Wells ${i + 1}:</label>
          <input type="number" 
                 id="x${i}" 
                 min="0" 
                 max="${defaultValues[numLevels].n[i]}" 
                 value="${defaultPositive}">
        </div>
      `;
    }
    container.innerHTML += '<button id="button" onclick="calculateMPN()">Calculate MPN</button>';

    // Add validation event listeners to each input
    for (let i = 0; i < numLevels; i++) {
      const input = document.getElementById(`x${i}`);
      const max = defaultValues[numLevels].n[i];
      input.addEventListener('input', function () {
        if (parseInt(this.value, 10) > max) {
          alert(`The number of positive wells cannot exceed the total number (${max}).`);
          this.value = max;
        }
        if (parseInt(this.value, 10) < 0) {
          this.value = 0;
        }
      });
    }
  }
    // end addDilutionLevels()

	// main MPN estimation function
	let allResults = []; // Array to store results  for download all results func
    function calculateMPN() {
      // Visual feedback - change button color
      const calcButton = document.getElementById('button');
      calcButton.style.backgroundColor = '#4CAF50'; // Green while calculating
      calcButton.textContent = 'Calculating...';

      // Restore button after brief delay
      setTimeout(() => {
        calcButton.style.backgroundColor = ''; 
        calcButton.textContent = 'Calculate MPN';
      }, 500);

      const numLevels = getSelectedNumLevels();
      if (![1, 2].includes(numLevels)) {
        document.getElementById('results').textContent = "Please select 1 or 2.";
        return;
      }

      // Predefined values
      const defaultValues = {
        1: {
          d: [0.01],
          w: [1.96],
          n: [51]
        },
        2: {
          d: [0.01, 0.01],
          w: [1.90, 0.16],
          n: [49, 48]
        }
      };

      // Get only x values from interface
      let x = [];
      for (let i = 0; i < numLevels; i++) {
        x.push(sanitizeInput(document.getElementById(`x${i}`).value));
      }

      // Use predefined values for other parameters
      const d = defaultValues[numLevels].d;
      const w = defaultValues[numLevels].w;
      const n = defaultValues[numLevels].n;

      // Check for invalid inputs
      if (x.some(value => value === null)) {
        document.getElementById('results').textContent = "Please enter valid numeric inputs.";
        return;
      }
      // Check if for one or two levels, all positives equal the total number of subsamples
      let allPositive = true; // Flag to check all levels are fully positive
      for (let i = 0; i < numLevels; i++) {
        if (x[i] !== n[i]) {
          allPositive = false;
          break;
        }
      }
	
      if (allPositive && (numLevels === 1 || numLevels === 2)) {
        alert("Warning: All wells are positive!");
        document.getElementById('results').innerHTML = "Result: NaN - All specified levels have positives equal to total number of wells. Results are not valid.";
        return; // Stop further execution
      }
	  
	  // Check if all positives are zero for either system
      let allZero = true;
      for (let i = 0; i < numLevels; i++) {
        if (x[i] !== 0) {
          allZero = false;
          break;
        }
      }
      if (allZero && (numLevels === 1 || numLevels === 2)) {
        alert("Warning: All Positive Wells are zero.");
        document.getElementById('results').innerHTML = "Result: NaN - All specified levels have zero positive wells. Results are not valid.";
        return; // Stop further execution
      }
	  
	  const thomasMpnResult = thomasMPN(x, n, d, w);
      //const initialGuess = 0.1; // Starting point for mu, change to thomas func
	  const initialGuess = thomasMpnResult * 0.5; 
      const tolerance = 1e-12; // Tolerance for convergence, make low for high dilution virus data
      const maxIterations = 100; // Maximum number of iterations
	  
	  // for Newton
      const result = calculateNewtonRaphsonMPN(d, w, x, n, initialGuess, tolerance, maxIterations);
	  const mpn = result.mpn;
	  // add rarity 
      const rarity = mpnErrorMetrics(x, d, n, w, mpn);
	  //confidence limits
	  const confidence = jarvisCLMPN(mpn, d, x, w);
	  const lowerCL = confidence.lowerCL;
	  const upperCL = confidence.upperCL; 
	  const xSim = xSimulate( mpn, n, x , w, d ); 
	  const timestamp = new Date().toLocaleString(); //new Date().toISOString(); 
	  const timestamp2 = new Date().toLocaleDateString();
	  const salMPN = salamaMPN(mpn, n, w, d);
 	  
	  //  For download allResults func
	allResults.push({
		sessionID: sessionID,
		timestamp: timestamp,
		d: d.join("_"),
		w: w.join("_"),
		x: x.join("_"),
		n: n.join("_"),
        mpn: mpn, //add toPrecision
		lowerCL: lowerCL, //add toPrecision
		upperCL: upperCL, //add toPrecision
        rarity: rarity.toPrecision(4),
        iterations: result.iterations,
		expectedXs: xSim.xSim.join("_"),
		ThomasMPN: thomasMpnResult,
		salMPN: salMPN
    });
	document.getElementById('results').innerHTML = `<div> <label> MPN: </label><label class=label2>${Math.round(mpn * 1000) / 1000} </label><div><label> 95%LL: </label><label class=label2>${Math.round(lowerCL * 1000)/1000}  </label><div><label> 95%UL: </label><label class=label2>${Math.round(upperCL * 1000)/1000}  </label><div><label> Rarity: </label><label class=label2>${rarity.toPrecision(4)}  </label><div><label> Iterations: </label><label class=label2>${result.iterations}  </label><div><label> Date: </label><label class=label2>${timestamp2}  </label> <div><label>xsim:</label><label class =label2> ${xSim.xSim.join("_")} </label> <div><label>Salama MPN: </label class=label2> ${Math.round(salMPN  * 1000)/1000}</label></div>`; 
     // document.getElementById('results').innerHTML = `xsim: ${xSim.xSim.join("_")}`
	  // add timestamp for this func
	 // document.getElementById('timedate').innerHTML = Date();
    }
    // end calculateMPN()
	
	// Main Newton func
    function calculateNewtonRaphsonMPN(d, w, x, n, initialGuess, tolerance, maxIterations) {
      let mu = initialGuess;
      let iterations = 0;
      for (let iteration = 0; iteration < maxIterations; iteration++) {
        iterations++;
		console.log("Newton iterations:", iterations);
        const firstDerivative = logMLEDerivative(mu, d, w, x, n); //uses helper function
        const secondDerivative = logMLESecondDerivative(mu, d, w, x, n); //uses helper function
        if (Math.abs(firstDerivative) < tolerance) {
          return { mpn: mu, iterations: iterations };
        }
        mu -= firstDerivative / secondDerivative;
		console.log("Newton MPN:", mu);
      }
	  
      return { mpn: mu, iterations: iterations };
    }
    // end calculateNewtonRaphsonMPN()

    // MPN first and second derivative helper functions for Newton
    function logMLEDerivative(mu, d, w, x, n) {
      return d.reduce((sum, di, i) => sum + (di * w[i] * x[i] / (1 - Math.exp(-di * w[i] * mu)) - n[i] * di * w[i]), 0);
    }

    function logMLESecondDerivative(mu, d, w, x, n) {
      return d.reduce((sum, di, i) => {
        let expTerm = Math.exp(-di * w[i] * mu);
        return sum - ((di * w[i]) ** 2 * x[i] * expTerm / ((1 - expTerm) ** 2));
      }, 0);
    }
    //end Newton helper functions
	
	
	//rarity begin
	// helper func
	function binomialCoefficient(n, x) {
		if (Number.isNaN(n) || Number.isNaN(x)) return NaN;
		if (x < 0 || x > n) return 0;
		if (x === 0 || x === n) return 1;
		if (x === 1 || x === n - 1) return n;

		if (n - x < x) x = n - x;
		let result = n;
		for (let i = 2; i <= x; i++) {
			result *= (n - i + 1) / i;
		}
		return Math.round(result);
	}
	// helper func
	function logChoose(n, x) {
		return Math.log(binomialCoefficient(n, x));
	}
	//main func
	function dbinom(x, n, p) {
		return logChoose(n, x) + x * Math.log(p) + (n - x) * Math.log(1 - p);
	}
	
    //main Rarity func See Blodgett and Jarvis
    function mpnErrorMetrics(x, d, n, w, mpn) {
        let p = d.map((di, i) => 1 - Math.exp(-mpn * di * w[i]));
        let mostLikelyX = n.map((ni, i) => Math.min(ni, Math.floor((ni * p[i]) + p[i]))); 
			let jointLikelihood = x.reduce((acc, xi, i) => {
			const likelihood = Math.exp(dbinom(xi, n[i], p[i]));
			if(isNaN(likelihood ) || likelihood === Infinity) {
				 return acc * 1e-50; // 1e-308;
			} else {
				return acc * likelihood;
			}
			}, 1);
			
		console.log('jointLikelihood :', jointLikelihood );
		let bestJointLikelihood = mostLikelyX.reduce((acc, mlxi, i) => {
			const bestLikelihood = Math.exp(dbinom(mlxi, n[i], p[i]));
			if(isNaN(bestLikelihood ) || bestLikelihood === Infinity) {
				 return acc * 1e-50; //1e-308;
			} else {
				return acc * bestLikelihood;
			}
			}, 1);
			
		console.log('bestJointLikelihood:', bestJointLikelihood);
		
		// trap flushes here too
		let ratio = jointLikelihood / bestJointLikelihood;
		// trap flushes here too
		console.log('Rarity :', ratio );
		return (isNaN(ratio ) ? "what data is this?" : ratio );
    }
    //rarity end
	
	
		//Expected x values
	function xSimulate( mpn, n, x , w, d ) {
		let p = d.map((di, i) => 1 - Math.exp(-mpn * di * w[i]));
        let mostLikelyX = n.map((ni, i) => Math.min(ni, Math.floor((ni * p[i]) + p[i])));
		return { xSim : mostLikelyX, p: p };
	}
	//end expected x values
	
	// 95% confidence limits func
	// Jarvis 95% CL
	function jarvisCLMPN(mpn, d, x, w) {
    //const sigLevel = 0.05;
    const critVal = 1.96; // Approximate (because JS doesnt have qnorm) Z-score for 95% confidence; adjust if necessary
    let varianceSum = 0;

    for (let i = 0; i < d.length; i++) {
        const expTerm = Math.exp(-d[i] * w[i] * mpn);
        const numer = x[i] * d[i] * d[i] * w[i] * w[i] * expTerm;
        const denom = (1 - expTerm) ** 2;
        varianceSum += numer / denom;
    }

    const variance = 1 / varianceSum;
    const varLogMPN = variance / (mpn * mpn); // Use mpn squared
    const seLog = Math.sqrt(varLogMPN);
    const meLog = critVal * seLog;

    const lowerCL = mpn * Math.exp(-meLog);
    const upperCL = mpn * Math.exp(meLog);

    return { lowerCL: lowerCL, upperCL: upperCL };
}
	//end Jarvis CL

  // Thomas MPN
  function thomasMPN(x, n, d, w) {
      // have the same length
      if (x.length !== n.length || x.length !== d.length || x.length !== w.length) {
          throw new Error("Thomas MPN arrays must have identical lengths");
      }
      const sumX = x.reduce((acc, val) => acc + val, 0);
      const sumDenominatorComponent = n.map((ni, index) => (ni - x[index]) * d[index] * w[index])
                                     .reduce((acc, val) => acc + val, 0);
      const sumNDW = n.map((ni, index) => ni * d[index] * w[index])
                    .reduce((acc, val) => acc + val, 0);
      const denominator = Math.sqrt(sumDenominatorComponent * sumNDW);
      const thomasMPN = sumX / denominator;
	  console.log('Estimated Thomas MPN:', thomasMPN);
      return thomasMPN;
}
	//end Thomas 

	//Salama MPN
	//helper func
	function mpnCosh(x) {
		return (Math.exp(x) + Math.exp(-x)) / 2;
	}
	//helper func
	function mpnSinh(x) {
		return (Math.exp(x) - Math.exp(-x)) / 2;
	}
	function salamaMPN(u, n, w, d) {
		if (u === 0) {
			return 0;
		} else if (!isFinite(u)) {
			return NaN;
		} else {
			const amount2 = w.map((wi, i) => Math.pow(wi * d[i], 2));
			const amount3 = w.map((wi, i) => Math.pow(wi * d[i], 3));
			const lambdaV = w.map((wi, i) => u * wi * d[i]);
			const ps = lambdaV.map(lv => 1 - Math.exp(-lv));
			const zi = ps.map((p, i) => n[i] * p);
			const coshTerm = lambdaV.map(lv => mpnCosh(lv) - 1);
			let D = zi.map((z, i) => (amount2[i] * z) / (2 * coshTerm[i])).reduce((acc, val) => acc + val, 0);
			let wi1 = amount2.map((a2, i) => a2 / (2 * Math.pow(ps[i], 2) * Math.pow(D, 3)));
			let wi2 = zi.map((z, i) => {
            let term = (amount3[i] * z * mpnSinh(lambdaV[i])) / Math.pow(coshTerm[i], 2);
            return isNaN(term) ? 0 : term;  // trap NaNs
        }).reduce((acc, val) => acc + val, 0);
			let wi3 = amount3.map((a3, i) => a3 / (ps[i] * coshTerm[i] * Math.pow(D, 2)));
			let wi = wi1.map((w1, i) => w1 * wi2 - wi3[i]);
			let results = u - 0.5 * wi.map((w, i) => w * zi[i] * Math.exp(-lambdaV[i])).reduce((acc, val) => acc + val, 0);
			console.log('Estimated salamaMPN:', results);
			return results;
    }
}
	// end Salama

	// download csv
	function downloadResults() {
  const maxResults = 1000;
  if (allResults.length > maxResults) {
    alert(`Too many results to download. The maximum allowed is ${maxResults}. Please reduce the number of calculations.`);
    return;
  }

  let csvContent = "data:text/csv;charset=utf-8,SessionID,Date,Time,Dilution(d),Volume(w),Positive(x),Total(n),MPN,95LL,95UL,Rarity,Iterations,expectedXs,ThomasMPN,SalamaMPN\n" 
    + allResults.map(result => {
      // Format numbers to remove apostrophes and limit decimal places
      const mpn = Number(result.mpn).toFixed(6);
      const lowerCL = Number(result.lowerCL).toFixed(6);
      const upperCL = Number(result.upperCL).toFixed(6);
      const thomasMPN = Number(result.ThomasMPN).toFixed(6);
      const salamaMPN = Number(result.salMPN).toFixed(6);
      
      return `${sessionID},${result.timestamp},${result.d},${result.w},${result.x},${result.n},${mpn},${lowerCL},${upperCL},${result.rarity},${result.iterations},${result.expectedXs},${thomasMPN},${salamaMPN}`;
    }).join("\n");

  const encodedUri = encodeURI(csvContent);
  const link = document.createElement("a");
  link.setAttribute("href", encodedUri);
  link.setAttribute("download", "mpn_results.csv");
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// Validate CSV headers
const validateCSV = (data) => {
  const requiredHeaders = ['SampleId', 'x', 'n', 'd', 'w'];
  const headers = data[0].map(h => h.trim());
  return requiredHeaders.every(header => headers.includes(header));
};

// Read and process CSV file
const readCSV = (file) => {
  const reader = new FileReader();
  reader.onload = () => {
    const lines = reader.result.split('\n').map(line => line.trim()).filter(line => line);
    const csvData = lines.map(line => line.split(',').map(cell => cell.trim()));

    if (!validateCSV(csvData)) {
      alert('Invalid CSV format. Please ensure the file contains required headers: SampleId, x, n, d, w');
      return;
    }

    processBatchMPN(csvData);
  };
  reader.readAsText(file);
};

// Process batch MPN calculations
const processBatchMPN = (csvData) => {
  const headers = csvData[0];
  const results = [['SessionID', 'Date', 'Time', 'Dilution(d)', 'Volume(w)', 'Positive(x)', 'Total(n)', 'MPN', '95LL', '95UL', 'Rarity', 'Iterations', 'expectedXs', 'ThomasMPN', 'SalamaMPN']];
  
  // Group data by SampleId
  const groupedData = {};
  for (let i = 1; i < csvData.length; i++) {
    const row = csvData[i];
    const sampleId = row[headers.indexOf('SampleId')];
    
    if (!groupedData[sampleId]) {
      groupedData[sampleId] = {
        x: [],
        n: [],
        d: [],
        w: []
      };
    }
    
    groupedData[sampleId].x.push(Number(row[headers.indexOf('x')]));
    groupedData[sampleId].n.push(Number(row[headers.indexOf('n')]));
    groupedData[sampleId].d.push(Number(row[headers.indexOf('d')]));
    groupedData[sampleId].w.push(Number(row[headers.indexOf('w')]));
  }

  for (const [sampleId, data] of Object.entries(groupedData)) {
    const currentDate = new Date().toLocaleDateString();
    const currentTime = new Date().toLocaleTimeString();
    
    let mpnResult, confidence, salamaMpn, rarity, xSim, thomasMpnResult;
    
    let allPositive = data.x.every((x, i) => x === data.n[i]);
    let allZero = data.x.every(x => x === 0);
    
    if (allPositive || allZero) {
      mpnResult = { mpn: NaN, iterations: 0 };
      confidence = { lowerCL: NaN, upperCL: NaN };
      salamaMpn = NaN;
      rarity = "NaN";
      xSim = { xSim: data.x.map(() => NaN) };
      thomasMpnResult = NaN;
    } else {
      thomasMpnResult = thomasMPN(data.x, data.n, data.d, data.w);
      const initialGuess = thomasMpnResult * 0.5;
      mpnResult = calculateNewtonRaphsonMPN(data.d, data.w, data.x, data.n, initialGuess, 0.0000001, 100);
      confidence = jarvisCLMPN(mpnResult.mpn, data.d, data.x, data.w);
      salamaMpn = salamaMPN(mpnResult.mpn, data.n, data.w, data.d);
      rarity = mpnErrorMetrics(data.x, data.d, data.n, data.w, mpnResult.mpn);
      xSim = xSimulate(mpnResult.mpn, data.n, data.x, data.w, data.d);
    }

    const formatNumber = (num) => {
      if (isNaN(num)) return "NaN";
      return Number(num).toFixed(6);
    };

    const formatRarity = (r) => {
      if (typeof r === 'number') {
        if (r < 1e-10) return r.toExponential(3);
        if (r < 0.0001) return r.toExponential(3);
        return r.toFixed(4);
      }
      return r;
    };

    results.push([
      sessionID,
      currentDate,
      currentTime,
      data.d.join('_'),
      data.w.join('_'),
      data.x.join('_'),
      data.n.join('_'),
      formatNumber(mpnResult.mpn),
      formatNumber(confidence.lowerCL),
      formatNumber(confidence.upperCL),
      formatRarity(rarity),
      mpnResult.iterations,
      xSim.xSim.join('_'),
      formatNumber(thomasMpnResult),
      formatNumber(salamaMpn)
    ]);
  }

  const csvContent = 'data:text/csv;charset=utf-8,' + 
    results.map(row => 
      row.map(cell => 
        typeof cell === 'string' && cell.includes(',') ? `"${cell}"` : cell
      ).join(',')
    ).join('\n');

  const encodedUri = encodeURI(csvContent);
  const link = document.getElementById('downloadLink');
  link.href = encodedUri;
  link.style.display = 'inline';
};

document.addEventListener('DOMContentLoaded', () => {
  loadData();
  // Set default radio and generate fields for 2 levels if not restoring from localStorage
  if (!localStorage.getItem('numLevels')) {
    document.getElementById('numLevels2').checked = true;
    addDilutionLevels(2);
  }
  // Add input validation for all numeric fields
  document.querySelectorAll('input[type="number"]').forEach(input => {
    input.addEventListener('input', function () {
      if (isNaN(this.value) || this.value === '') {
        this.value = ''; // Clear invalid input
        alert('Please enter a valid numeric value.');
      }
    });
  });

  // Add CSV upload listeners
  const csvInput = document.getElementById('csvInput');
  const processBtn = document.getElementById('processBtn');

  // Modify the CSV input event listener to remove download link display
  csvInput.addEventListener('change', (event) => {
    const file = event.target.files[0];
    const fileNameDisplay = document.getElementById('selectedFileName');
    
    if (file) {
      if (file.size > 2 * 1024 * 1024) {
        alert('File size exceeds 2MB limit.');
        csvInput.value = '';
        fileNameDisplay.textContent = '';
        return;
      }
      fileNameDisplay.textContent = file.name;
    } else {
      fileNameDisplay.textContent = '';
    }
  });

  // Update the process button click handler
  processBtn.addEventListener('click', () => {
    if (!csvInput.files[0]) {
      alert('Please select a CSV file first.');
      return;
    }

    // Visual feedback
    processBtn.style.backgroundColor = '#4CAF50';
    processBtn.textContent = 'Calculating...';
    processBtn.disabled = true;

    setTimeout(() => {
      readCSV(csvInput.files[0]);
      
      // Show download link after calculation
      const downloadLink = document.getElementById('downloadLink');
      downloadLink.style.display = 'inline';
      
      // Reset button state
      processBtn.style.backgroundColor = '';
      processBtn.textContent = 'Calculate Batch MPN';
      processBtn.disabled = false;
    }, 500);
  });
});

document.addEventListener('input', saveData);

function sanitizeInput(value, min = 0, max = Infinity) {
  const num = parseFloat(value);
  if (isNaN(num) || num < min || num > max) {
    return null; // Invalid input
  }
  return num;
}

function toggleButtonState() {
  const numLevels = document.getElementById('numLevels').value;
  const isValid = !isNaN(numLevels) && numLevels >= 1 && numLevels <= 2;
  document.getElementById('generateButton').disabled = !isValid;
}

function resetForm() {
  if (confirm("Are you sure you want to reset the form? This will clear all inputs and results.")) {
    // Reset radio buttons to default (2 checked)
    document.getElementById('numLevels1').checked = false;
    document.getElementById('numLevels2').checked = true;

    // Regenerate input fields for 2 levels
    addDilutionLevels(2);

    // Clear results
    document.getElementById('results').innerHTML = '';

    // Clear stored results and localStorage
    allResults = [];
    localStorage.clear();
    console.log("Form and localStorage have been reset.");
  }
}

function saveData() {
  const numLevels = document.getElementById('numLevels').value;
  const inputFields = Array.from(document.querySelectorAll('#inputFields input')).map(input => ({
    id: input.id,
    value: input.value
  }));
  localStorage.setItem('numLevels', numLevels);
  localStorage.setItem('inputFields', JSON.stringify(inputFields));
  localStorage.setItem('allResults', JSON.stringify(allResults));
  console.log("Data saved to localStorage.");
}

function loadData() {
  const numLevels = localStorage.getItem('numLevels');
  const inputFields = JSON.parse(localStorage.getItem('inputFields'));
  const savedResults = JSON.parse(localStorage.getItem('allResults'));

  if (numLevels) {
    document.getElementById('numLevels').value = numLevels;
    toggleButtonState(); // Enable the "Generate" button if valid
    addDilutionLevels(); // Regenerate input fields
  }

  if (inputFields) {
    inputFields.forEach(field => {
      const input = document.getElementById(field.id);
      if (input) {
        input.value = field.value; // Populate the input field with the saved value
      }
    });
  }

  if (savedResults) {
    allResults = savedResults;
    console.log("Results loaded from localStorage:", allResults);
  }
}
	// end download
  </script>
  

<br>
<p>
<button id="button" onclick="downloadResults()">Download All Results</button>
<br>
<br>
<button onclick="resetForm()">Reset</button>
<br>
</p>

<div id="csv-section" style="background:#f9f9f9;border:1px solid #ddd;border-radius:6px;padding:1.2em 1.5em;margin:2em 0;">
  <h3 style="color:#205493;margin-top:0;">Batch MPN Calculations</h3>
  <p>Upload a CSV file with columns: SampleId, x, n, d, w</p>
  <div class="batch-controls">
    <div class="batch-input">
      <div class="file-input-wrapper">
        <input type="file" id="csvInput" accept=".csv" style="display:none" />
        <label for="csvInput" style="min-width:120px;">Select CSV File</label>
        <span id="selectedFileName" class="file-name"></span>
      </div>
    </div>
    <button id="processBtn" aria-label="Calculate Batch MPN">Calculate Batch MPN</button>
    <a id="downloadLink" download="mpn_batch_results.csv" style="display: none;" aria-label="Download Batch MPN Results">
      <button>Download Results</button>
    </a>
  </div>
</div>

<div id="help-section" style="background:#eef6fb;border:1px solid #bcdff1;border-radius:6px;padding:1.2em 1.5em;margin:2em 0;">
  <h3 style="color:#205493;margin-top:0;">Help &amp; Info</h3>
  <ul style="line-height:1.7;">
    <li><strong>Select System:</strong> Choose "1" or "2" to match your tray system.</li>
    <li><strong>Positive Wells:</strong> Enter the number of positive wells for each level. This must be between 0 and the total number of wells for that level.</li>
    <li><strong>Calculate MPN:</strong> Click this button to estimate the Most Probable Number (MPN), confidence limits and other statistics.</li>
    <li><strong>Download All Results:</strong> Download a CSV file of all your calculations for this session.</li>
    <li><strong>Reset:</strong> Clears all inputs and results (including downloaded CSV), and resets the form to default values.</li>
    <li><strong>About:</strong> This tool estimates MPN using the Newton-Raphson method and provides confidence intervals. </li>
  </ul>
  <p style="font-size:0.95em;color:#205493;">
    <strong>Feedback:</strong> If you have questions or feedback, please contact the developer.
  </p>
</div>
</body>
</html>
